<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="generic,">










<meta name="description" content="动态数组容器类ArrayList。">
<meta name="keywords" content="generic">
<meta property="og:type" content="article">
<meta property="og:title" content="java容器ArrayList">
<meta property="og:url" content="http://yoursite.com/2019/03/15/container-arrayList/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="动态数组容器类ArrayList。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-15T12:06:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java容器ArrayList">
<meta name="twitter:description" content="动态数组容器类ArrayList。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/15/container-arrayList/">





  <title>java容器ArrayList | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/15/container-arrayList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Adtle123">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java容器ArrayList</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-15T20:06:50+08:00">
                2019-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  动态数组容器类ArrayList。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>从本节开始，我们探讨Java中的容器类，所谓容器，顾名思义就是容纳其他数据的，计算机课程中有一门课叫数据结构，可以粗略对应于Java中的容器类，我们不会介绍所有数据结构的内容，但会介绍Java中的主要实现，并分析其基本原理和主要实现代码。</p>
<p>我们介绍Java中真正的动态数组容器类ArrayList。</p>
<p>我们先来看它的基本用法。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="新建ArrayList"><a href="#新建ArrayList" class="headerlink" title="新建ArrayList"></a>新建ArrayList</h3><p>ArrayList是一个泛型容器，新建ArrayList需要实例化泛型参数，比如：</p>
<pre><code>ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();
</code></pre><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>add方法添加元素到末尾</p>
<pre><code>ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
intList.add(123);
intList.add(456);
ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();
strList.add(&quot;老马&quot;);
strList.add(&quot;编程&quot;);
</code></pre><h3 id="长度方法"><a href="#长度方法" class="headerlink" title="长度方法"></a>长度方法</h3><p>判断是否为空</p>
<pre><code>public boolean isEmpty()
</code></pre><p>获取长度</p>
<pre><code>public int size()
</code></pre><h3 id="访问指定位置的元素"><a href="#访问指定位置的元素" class="headerlink" title="访问指定位置的元素"></a>访问指定位置的元素</h3><pre><code>public E get(int index)
</code></pre><p>如：</p>
<pre><code>ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;();
strList.add(&quot;老马&quot;);
strList.add(&quot;编程&quot;);
for(int i=0; i&lt;strList.size(); i++){
    System.out.println(strList.get(i));
}
</code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre><code>public int indexOf(Object o)
</code></pre><p>如果找到，返回索引位置，否则返回-1。</p>
<p>从后往前找</p>
<pre><code>public int lastIndexOf(Object o)
</code></pre><p>是否包含指定元素</p>
<pre><code>public boolean contains(Object o)
</code></pre><p>相同的依据是equals方法返回true。如果传入的元素为null，则找null的元素。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>删除指定位置的元素</p>
<pre><code>public E remove(int index)
</code></pre><p>返回值为被删对象。</p>
<p>删除指定对象</p>
<pre><code>public boolean remove(Object o)
</code></pre><p>与indexOf一样，比较的依据的是equals方法，如果o为null，则删除值为null的元素。另外，remove只删除第一个相同的对象，也就是说，即使ArrayList中有多个与o相同的元素，也只会删除第一个。返回值为boolean类型，表示是否删除了元素。</p>
<p>删除所有元素</p>
<pre><code>public void clear() 
</code></pre><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>在指定位置插入元素</p>
<pre><code>public void add(int index, E element)
</code></pre><p>index为0表示插入最前面，index为ArrayList的长度表示插到最后面。</p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>修改指定位置的元素内容</p>
<pre><code>public E set(int index, E element) 
</code></pre><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h3><p>可以看出，ArrayList的基本用法是比较简单的，它的基本原理也是比较简单的，原理与我们在前面几节介绍的DynaArray类似，内部有一个数组elementData，一般会有一些预留的空间，有一个整数size记录实际的元素个数，如下所示：</p>
<pre><code>private transient Object[] elementData;
private int size;
</code></pre><p>我们暂时可以忽略transient这个关键字。各种public方法内部操作的基本都是这个数组和这个整数，elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数。</p>
<h3 id="Add方法"><a href="#Add方法" class="headerlink" title="Add方法"></a>Add方法</h3><p>虽然基本思路是简单的，但内部代码有一些比较晦涩，我们来看下add方法的代码：</p>
<pre><code>public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
</code></pre><p>它首先调用ensureCapacityInternal确保数组容量是够的，ensureCapacityInternal的代码是：</p>
<pre><code>private void ensureCapacityInternal(int minCapacity) {
    if (elementData == EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
</code></pre><p>它先判断数组是不是空的，如果是空的，则首次至少要分配的大小为<code>DEFAULT_CAPACITY</code>，<code>DEFAULT_CAPACITY</code>的值为10，接下来调用ensureExplicitCapacity，代码为：</p>
<pre><code>private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
</code></pre><p>modCount++是什么意思呢？modCount表示内部的修改次数，modCount++当然就是增加修改次数，为什么要记录修改次数呢？我们待会解释。</p>
<p>如果需要的长度大于当前数组的长度，则调用grow方法。这段代码前面有个注释：overflow-conscious code，翻译一下，大意就是代码考虑了溢出这种情况，溢出是什么意思呢？我们解释下，假设a,b都是int，下面两行代码是不一样的：</p>
<pre><code>1 if(a&gt;b)
2 if(a-b&gt;0)
</code></pre><p>为什么呢？考虑<code>a=Integer.MAX_VALUE, b=Integer.MIN_VALUE</code>：</p>
<p>a&gt;b为true</p>
<p>但由于溢出，a-b的结果为-1</p>
<p>反之，再考虑<code>a=Integer.MIN_VALUE, b=Integer.MAX_VALUE</code>:</p>
<p>a&gt;b为false</p>
<p>但由于溢出，a-b的结果为1。</p>
<p>不过，在a, b都为正数且数值没有那么大的情况下，一般也没有溢出问题，为便于理解，在后续的分析中，我们将忽略溢出问题。</p>
<p>接下来，看grow方法：</p>
<pre><code>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre><p>排除边缘情况，长度增长的主要代码为：</p>
<pre><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
</code></pre><p>右移一位相当于除2，所以，newCapacity相当于oldCapacity的1.5倍。</p>
<h3 id="Remove方法"><a href="#Remove方法" class="headerlink" title="Remove方法"></a>Remove方法</h3><p>我们再来看Remove方法的代码：</p>
<pre><code>public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
</code></pre><p>它也增加了modCount，然后计算要移动的元素个数，从index往后的元素都往前移动一位，实际调用System.arraycopy方法移动元素。<code>elementData[--size] = null;</code>这行代码将size减一，同时将最后一个位置设为null，设为null后就不再引用原来对象，如果原来对象也不再被其他对象引用，就可以被垃圾回收。</p>
<h3 id="基本原理小结"><a href="#基本原理小结" class="headerlink" title="基本原理小结"></a>基本原理小结</h3><p>其他方法大多是比较简单的，我们就不赘述了。总体而言，内部操作要考虑各种情况，代码有一些晦涩复杂，但接口一般都是简单直接的，这就是使用容器类的好处了，这也是计算机程序中的基本思维方式，封装复杂操作，提供简单接口。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><h3 id="foreach用法"><a href="#foreach用法" class="headerlink" title="foreach用法"></a>foreach用法</h3><p>理解了ArrayList的基本用法和原理，接下来，我们来看一个常见的操作 - 迭代，比如说，循环打印ArrayList中的每个元素，ArrayList支持foreach语法，比如：</p>
<pre><code>ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
intList.add(123);
intList.add(456);
intList.add(789);
for(Integer a : intList){
    System.out.println(a);
}
</code></pre><p>当然，这种循环也可以使用如下代码实现：</p>
<pre><code>for(int i=0; i&lt;intList.size(); i++){
    System.out.println(intList.get(i));
}
</code></pre><p>不过，foreach看上去更为简洁，而且，它适用于各种容器，更为通用。</p>
<p>这种foreach语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：</p>
<pre><code>Iterator&lt;Integer&gt; it = intList.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
</code></pre><p>接来下，我们解释一下其中的代码。</p>
<h3 id="迭代器接口"><a href="#迭代器接口" class="headerlink" title="迭代器接口"></a>迭代器接口</h3><p>ArrayList实现了Iterable接口，Iterable表示可迭代，它的定义为：</p>
<pre><code>public interface Iterable&lt;T&gt; {
    Iterator&lt;T&gt; iterator();
}
</code></pre><p>定义很简单，就是要求实现iterator方法。iterator方法的声明为：</p>
<pre><code>public Iterator&lt;E&gt; iterator()
</code></pre><p>它返回一个实现了Iterator接口的对象，Iterator接口的定义为：</p>
<pre><code>public interface Iterator&lt;E&gt; {
    boolean hasNext();
    E next();
    void remove();
}
</code></pre><p>hasNext()判断是否还有元素未访问，next()返回下一个元素，remove()删除最后返回的元素，只读访问的基本模式就类似于：</p>
<pre><code>Iterator&lt;Integer&gt; it = intList.iterator();
while(it.hasNext()){
    System.out.println(it.next());
}
</code></pre><p>我们待会再看迭代中间要删除元素的情况。</p>
<p>只要对象实现了Iterable接口，就可以使用foreach语法，编译器会转换为调用Iterable和Iterator接口的方法。</p>
<p>初次见到Iterable和Iterator，可能会比较容易混淆，我们再澄清一下：</p>
<ul>
<li>Iterable表示对象可以被迭代，它有一个方法iterator()，返回Iterator对象，实际通过Iterator接口的方法进行遍历。</li>
<li>如果对象实现了Iterable，就可以使用foreach语法。</li>
<li>类可以不实现Iterable，也可以创建Iterator对象。</li>
</ul>
<h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>除了iterator()，ArrayList还提供了两个返回Iterator接口的方法：</p>
<pre><code>public ListIterator&lt;E&gt; listIterator()
public ListIterator&lt;E&gt; listIterator(int index)
</code></pre><p>ListIterator扩展了Iterator接口，增加了一些方法，向前遍历、添加元素、修改元素、返回索引位置等，添加的方法有：</p>
<pre><code>public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void set(E e);
    void add(E e);
}
</code></pre><p>listIterator()方法返回的迭代器从0开始，而<code>listIterator(int index)</code>方法返回的迭代器从指定位置index开始，比如，从末尾往前遍历，代码为：</p>
<pre><code>public void reverseTraverse(List&lt;Integer&gt; list){
    ListIterator&lt;Integer&gt; it = list.listIterator(list.size());
    while(it.hasPrevious()){
        System.out.println(it.previous());
    }
}
</code></pre><h3 id="迭代的陷阱"><a href="#迭代的陷阱" class="headerlink" title="迭代的陷阱"></a>迭代的陷阱</h3><p>关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法，比如要删除一个整数ArrayList中所有小于100的数，直觉上，代码可以这么写：</p>
<pre><code>public void remove(ArrayList&lt;Integer&gt; list){
    for(Integer a : list){
        if(a&lt;=100){
            list.remove(a);
        }
    }
}
</code></pre><p>但，运行时会抛出异常：</p>
<pre><code>java.util.ConcurrentModificationException
</code></pre><p>发生了并发修改异常，为什么呢？迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p>
<p>如何避免异常呢？可以使用迭代器的remove方法，如下所示：</p>
<pre><code>public static void remove(ArrayList&lt;Integer&gt; list){
    Iterator&lt;Integer&gt; it = list.iterator();
    while(it.hasNext()){
        if(it.next()&lt;=100){
            it.remove();
        }
    }
}
</code></pre><p>迭代器如何知道发生了结构性变化，并抛出异常？它自己的remove方法为何又可以使用呢？我们需要看下迭代器的工作原理。</p>
<h3 id="迭代器实现的原理"><a href="#迭代器实现的原理" class="headerlink" title="迭代器实现的原理"></a>迭代器实现的原理</h3><p>我们来看下ArrayList中iterator方法的实现，代码为：</p>
<pre><code>public Iterator&lt;E&gt; iterator() {
    return new Itr();
}
</code></pre><p>新建了一个Itr对象，Itr是一个成员内部类，实现了Iterator接口，声明为：</p>
<pre><code>private class Itr implements Iterator&lt;E&gt;
</code></pre><p>它有三个实例成员变量，为：</p>
<pre><code>int cursor;       // index of next element to return
int lastRet = -1; // index of last element returned; -1 if no such
int expectedModCount = modCount;
</code></pre><p>cursor表示下一个要返回的元素位置，lastRet表示最后一个返回的索引位置，expectedModCount表示期望的修改次数，初始化为外部类当前的修改次数modCount，回顾一下，成员内部类可以直接访问外部类的实例变量。</p>
<p>每次发生结构性变化的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。</p>
<p>我们来具体看下，它是如何实现Iterator接口中的每个方法的，先看hasNext()，代码为：</p>
<pre><code>public boolean hasNext() {
    return cursor != size;
}
</code></pre><p>cursor与size比较，比较直接，看next()方法：</p>
<pre><code>public E next() {
    checkForComodification();
    int i = cursor;
    if (i &gt;= size)
        throw new NoSuchElementException();
    Object[] elementData = ArrayList.this.elementData;
    if (i &gt;= elementData.length)
        throw new ConcurrentModificationException();
    cursor = i + 1;
    return (E) elementData[lastRet = i];
}
</code></pre><p>首先调用了checkForComodification，它的代码为：</p>
<pre><code>final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
</code></pre><p>所以，next()前面部分主要就是在检查是否发生了结构性变化，如果没有变化，就更新cursor和lastRet的值，以保持其语义，然后返回对应的元素。</p>
<p>remove的代码为：</p>
<pre><code>public void remove() {
    if (lastRet &lt; 0)
        throw new IllegalStateException();
    checkForComodification();

    try {
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
    }
}
</code></pre><p>它调用了ArrayList的remove方法，但同时更新了cursor, lastRet和expectedModCount的值，所以它可以正确删除。</p>
<p>不过，需要注意的是，调用remove方法前必须先调用next，比如，通过迭代器删除所有元素，直觉上，可以这么写：</p>
<pre><code>public static void removeAll(ArrayList&lt;Integer&gt; list){
    Iterator&lt;Integer&gt; it = list.iterator();
    while(it.hasNext()){
        it.remove();    
    }
}
</code></pre><p>实际运行，会抛出异常：</p>
<pre><code>java.lang.IllegalStateException
</code></pre><p>正确写法是：</p>
<pre><code>public static void removeAll(ArrayList&lt;Integer&gt; list){
    Iterator&lt;Integer&gt; it = list.iterator();
    while(it.hasNext()){
        it.next();
        it.remove();
    }
}
</code></pre><p>当然，如果只是要删除所有元素，ArrayList有现成的方法clear()。</p>
<p>listIterator()的实现使用了另一个内部类ListItr，它继承自Itr，基本思路类似，我们就不赘述了。</p>
<h3 id="迭代器的好处"><a href="#迭代器的好处" class="headerlink" title="迭代器的好处"></a>迭代器的好处</h3><p>为什么要通过迭代器这种方式访问元素呢？直接使用size()/get(index)语法不也可以吗？在一些场景下，确实没有什么差别，两者都可以。不过，foreach语法更为简洁一些，更重要的是，迭代器语法更为通用，它适用于各种容器类。</p>
<p>此外，迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式。需要访问容器元素的代码只需要一个Iterator接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。</p>
<p>而提供Iterator接口的代码了解数据的组织方式，可以提供高效的实现。在ArrayList中, size/get(index)语法与迭代器性能是差不多的，但在后续介绍的其他容器中，则不一定，比如LinkedList，迭代器性能就要高很多。</p>
<p>从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。</p>
<h2 id="ArrayList实现的接口"><a href="#ArrayList实现的接口" class="headerlink" title="ArrayList实现的接口"></a>ArrayList实现的接口</h2><p>Java的各种容器类有一些共性的操作，这些共性以接口的方式体现，我们刚刚介绍的Iterable接口就是，此外，ArrayList还实现了三个主要的接口Collection, List和RandomAccess，我们逐个来看下。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>Collection表示一个数据集合，数据间没有位置或顺序的概念，接口定义为：</p>
<pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    boolean retainAll(Collection&lt;?&gt; c);
    void clear();
    boolean equals(Object o);
    int hashCode();
}
</code></pre><p>这些方法中，除了两个toArray方法和几个xxxAll()方法外，其他我们已经介绍过了。</p>
<p>这几个xxxAll()方法的含义基本也是可以顾名思义的，addAll添加，removeAll删除，containsAll检查是否包含了参数容器中的所有元素，只有全包含才返回true，retainAll只保留参数容器中的元素，其他元素会进行删除。</p>
<p>有一个抽象类AbstractCollection对这几个方法都提供了默认实现，实现的方式就是利用迭代器方法逐个操作，比如说，我们看removeAll方法，代码为：</p>
<pre><code>public boolean removeAll(Collection&lt;?&gt; c) {
    boolean modified = false;
    Iterator&lt;?&gt; it = iterator();
    while (it.hasNext()) {
        if (c.contains(it.next())) {
            it.remove();
            modified = true;
        }
    }
    return modified;
}
</code></pre><p>代码比较简单，就不解释了。ArrayList继承了AbstractList，而AbstractList又继承了AbstractCollection，ArrayList对其中一些方法进行了重写，以提供更为高效的实现，具体我们就不介绍了。</p>
<p>关于toArray方法，我们待会再介绍。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List表示有顺序或位置的数据集合，它扩展了Collection，增加的主要方法有：</p>
<pre><code>boolean addAll(int index, Collection&lt;? extends E&gt; c);
E get(int index);
E set(int index, E element);
void add(int index, E element);
E remove(int index);
int indexOf(Object o);
int lastIndexOf(Object o);
ListIterator&lt;E&gt; listIterator();
ListIterator&lt;E&gt; listIterator(int index);
List&lt;E&gt; subList(int fromIndex, int toIndex);
</code></pre><p>这些方法都与位置有关，容易理解，就不介绍了。</p>
<h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h3><p>RandomAccess的定义为：</p>
<pre><code>public interface RandomAccess {
}
</code></pre><p>没有定义任何代码。这有什么用呢？这种没有任何代码的接口在Java中被称之为标记接口，用于声明类的一种属性。</p>
<p>这里，实现了RandomAccess接口的类表示可以随机访问，可随机访问就是具备类似数组那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。下节我们会介绍LinkedList，它就不能随机访问。</p>
<p>有没有声明RandomAccess有什么关系呢？主要用于一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现。比如说，Collections类中有一个方法binarySearch，在List中进行二分查找，它的实现代码就根据list是否实现了RandomAccess而采用不同的实现机制，如下所示：</p>
<pre><code>public static &lt;T&gt;
int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {
    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}
</code></pre><h2 id="ArrayList的其他方法"><a href="#ArrayList的其他方法" class="headerlink" title="ArrayList的其他方法"></a>ArrayList的其他方法</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ArrayList还有两个构造方法</p>
<pre><code>public ArrayList(int initialCapacity)
public ArrayList(Collection&lt;? extends E&gt; c)
</code></pre><p>第一个方法以指定的大小initialCapacity初始化内部的数组大小，代码为：</p>
<pre><code>this.elementData = new Object[initialCapacity];
</code></pre><p>在事先知道元素长度的情况下，或者，预先知道长度上限的情况下，使用这个构造方法可以避免重新分配和拷贝数组。</p>
<p>第二个构造方法以一个已有的Collection构建，数据会新拷贝一份。</p>
<h3 id="与数组的相互转换"><a href="#与数组的相互转换" class="headerlink" title="与数组的相互转换"></a>与数组的相互转换</h3><p>ArrayList中有两个方法可以返回数组</p>
<pre><code>public Object[] toArray()
public &lt;T&gt; T[] toArray(T[] a) 
</code></pre><p>第一个方法返回是Object数组，代码为：</p>
<pre><code>public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}
</code></pre><p>第二个方法返回对应类型的数组，如果参数数组长度足以容纳所有元素，就使用该数组，否则就新建一个数组，比如：</p>
<pre><code>ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
intList.add(123);
intList.add(456);
intList.add(789);

Integer[] arrA = new Integer[3];
intList.toArray(arrA);
Integer[] arrB = intList.toArray(new Integer[0]);

System.out.println(Arrays.equals(arrA, arrB));
</code></pre><p>输出为true，表示两种方式都是可以的。</p>
<p>Arrays中有一个静态方法asList可以返回对应的List，如下所示：</p>
<pre><code>Integer[] a = {1,2,3};
List&lt;Integer&gt; list = Arrays.asList(a);
</code></pre><p>需要注意的是，这个方法返回的List，它的实现类并不是本节介绍的ArrayList，而是Arrays类的一个内部类，在这个内部类的实现中，内部用的的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反映到List中，对List调用add/remove方法会抛出异常。</p>
<p>要使用ArrayList完整的方法，应该新建一个ArrayList，如下所示：</p>
<pre><code>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(a));
</code></pre><h3 id="容量大小控制"><a href="#容量大小控制" class="headerlink" title="容量大小控制"></a>容量大小控制</h3><p>ArrayList还提供了两个public方法，可以控制内部使用的数组大小，一个是：</p>
<pre><code>public void ensureCapacity(int minCapacity)
</code></pre><p>它可以确保数组的大小至少为minCapacity，如果不够，会进行扩展。如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数。</p>
<p>另一个方法是：</p>
<pre><code>public void trimToSize()
</code></pre><p>它会重新分配一个数组，大小刚好为实际内容的长度。调用这个方法可以节省数组占用的空间。</p>
<h2 id="ArrayList特点分析"><a href="#ArrayList特点分析" class="headerlink" title="ArrayList特点分析"></a>ArrayList特点分析</h2><p>后续我们会介绍各种容器类和数据组织方式，之所以有各种不同的方式，是因为不同方式有不同特点，而不同特点有不同适用场合。考虑特点时，性能是其中一个很重要的部分，但性能不是一个简单的高低之分，对于一种数据结构，有的操作性能高，有的操作性能可能就比较低。</p>
<p>作为程序员，就是要理解每种数据结构的特点，根据场合的不同，选择不同的数据结构。</p>
<p>对于ArrayList，它的特点是：内部采用动态数组实现，这决定了：</p>
<ul>
<li>可以随机访问，按照索引位置进行访问效率很高，用算法描述中的术语，效率是O(1)，简单说就是可以一步到位。</li>
<li>除非数组已排序，否则按照内容查找元素效率比较低，具体是O(N)，N为数组内容长度，也就是说，性能与数组长度成正比。</li>
<li>添加元素的效率还可以，重新分配和拷贝数组的开销被平摊了，具体来说，添加N个元素的效率为O(N)。</li>
<li>插入和删除元素的效率比较低，因为需要移动元素，具体为O(N)。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了ArrayList，ArrayList是日常开发中最常用的类之一。我们介绍了ArrayList的用法、基本实现原理、迭代器及其实现、Collection/List/RandomAccess接口、ArrayList与数组的相互转换，最后我们分析了ArrayList的特点。</p>
<p>ArrayList的插入和删除的性能比较低，下一节，我们来看另一个同样实现了List接口的容器类，LinkedList，它的特点可以说与ArrayList正好相反。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/generic/" rel="tag"># generic</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/15/generic-03/" rel="next" title="java泛型一些细节和局限性(03)">
                <i class="fa fa-chevron-left"></i> java泛型一些细节和局限性(03)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/15/synchronized/" rel="prev" title="synchronized底层语义">
                synchronized底层语义 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Adtle123</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本用法"><span class="nav-number">1.</span> <span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#新建ArrayList"><span class="nav-number">1.1.</span> <span class="nav-text">新建ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加元素"><span class="nav-number">1.2.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#长度方法"><span class="nav-number">1.3.</span> <span class="nav-text">长度方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问指定位置的元素"><span class="nav-number">1.4.</span> <span class="nav-text">访问指定位置的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找元素"><span class="nav-number">1.5.</span> <span class="nav-text">查找元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除元素"><span class="nav-number">1.6.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入元素"><span class="nav-number">1.7.</span> <span class="nav-text">插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改元素"><span class="nav-number">1.8.</span> <span class="nav-text">修改元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">2.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部组成"><span class="nav-number">2.1.</span> <span class="nav-text">内部组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Add方法"><span class="nav-number">2.2.</span> <span class="nav-text">Add方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove方法"><span class="nav-number">2.3.</span> <span class="nav-text">Remove方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本原理小结"><span class="nav-number">2.4.</span> <span class="nav-text">基本原理小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代"><span class="nav-number">3.</span> <span class="nav-text">迭代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach用法"><span class="nav-number">3.1.</span> <span class="nav-text">foreach用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器接口"><span class="nav-number">3.2.</span> <span class="nav-text">迭代器接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ListIterator"><span class="nav-number">3.3.</span> <span class="nav-text">ListIterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代的陷阱"><span class="nav-number">3.4.</span> <span class="nav-text">迭代的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器实现的原理"><span class="nav-number">3.5.</span> <span class="nav-text">迭代器实现的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器的好处"><span class="nav-number">3.6.</span> <span class="nav-text">迭代器的好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList实现的接口"><span class="nav-number">4.</span> <span class="nav-text">ArrayList实现的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection"><span class="nav-number">4.1.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">4.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccess"><span class="nav-number">4.3.</span> <span class="nav-text">RandomAccess</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList的其他方法"><span class="nav-number">5.</span> <span class="nav-text">ArrayList的其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">5.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与数组的相互转换"><span class="nav-number">5.2.</span> <span class="nav-text">与数组的相互转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容量大小控制"><span class="nav-number">5.3.</span> <span class="nav-text">容量大小控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList特点分析"><span class="nav-number">6.</span> <span class="nav-text">ArrayList特点分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Adtle123</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
